
https://blog.csdn.net/pange1991/article/details/85460755
# 1 排序算法的[时间复杂度](https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&spm=1001.2101.3001.7020)和空间复杂度

|            |             |             |             |           |         |
| ---------- | ----------- | ----------- | ----------- | --------- | ------- |
| **排序算法**   | **平均时间复杂度** | **最坏时间复杂度** | **最好时间复杂度** | **空间复杂度** | **稳定性** |
| **冒泡排序**   | O(n²)       | O(n²)       | O(n)        | O(1)      | 稳定      |
| **直接选择排序** | O(n²)       | O(n²)       | O(n)        | O(1)      | 不稳定     |
| **直接插入排序** | O(n²)       | O(n²)       | O(n)        | O(1)      | 稳定      |
| **快速排序**   | O(nlogn)    | O(n²)       | O(nlogn)    | O(nlogn)  | 不稳定     |
| **堆排序**    | O(nlogn)    | O(nlogn)    | O(nlogn)    | O(1)      | 不稳定     |
| **希尔排序**   | O(nlogn)    | O(ns)       | O(n)        | O(1)      | 不稳定     |
| **归并排序**   | O(nlogn)    | O(nlogn)    | O(nlogn)    | O(n)      | 稳定      |
| **计数排序**   | O(n+k)      | O(n+k)      | O(n+k)      | O(n+k)    | 稳定      |
| **基数排序**   | O(N*M)      | O(N*M)      | O(N*M)      | O(M)      | 稳定      |


**注**：
1 归并排序可以通过手摇算法将[空间复杂度](https://so.csdn.net/so/search?q=%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&spm=1001.2101.3001.7020)降到O(1)，但是时间复杂度会提高。
2 基数排序时间复杂度为O(N*M)，其中N为数据个数，M为数据位数。

**辅助记忆**

时间复杂度记忆
1. 冒泡、选择、直接 排序需要两个for循环，每次只关注一个元素，平均时间复杂度为O(n²)）（一遍找元素O(n)，一遍找位置O(n)）
2. 快速、归并、希尔、堆基于二分思想，log以2为底，平均时间复杂度为O(nlogn)（一遍找元素O(n)，一遍找位置O(logn)）

稳定性记忆-“快希选堆”（快牺牲稳定性） 
1. 排序算法的稳定性：排序前后相同元素的相对位置不变，则称排序算法是稳定的；否则排序算法是不稳定的。


# 2 冒泡排序BubbleSort


|          |             |             |             |           |         |
| -------- | ----------- | ----------- | ----------- | --------- | ------- |
| **排序算法** | **平均时间复杂度** | **最坏时间复杂度** | **最好时间复杂度** | **空间复杂度** | **稳定性** |
| **冒泡排序** | O(n²)       | O(n²)       | O(n)        | O(1)      | 稳定      |

冒泡排序从小到大排序：
一开始交换的区间为0~N-1，将第1个数和第2个数进行比较，前面大于后面，交换两个数，否则不交换。再比较第2个数和第三个数，前面大于后面，交换两个数否则不交换。依次进行，最大的数会放在数组最后的位置。
然后将范围变为0~N-2，数组第二大的数会放在数组倒数第二的位置。
依次进行整个交换过程，最后范围只剩一个数时数组即为有序。

![](https://i-blog.csdnimg.cn/blog_migrate/ec52b59618c639c3e3c1e0967eeee674.gif)


```c++
//array[]为待排序数组，n为数组长度
void BubbleSort(int array[], int n)
{
    int i, j, k;
    for(i=0; i<n-1; i++)
        for(j=0; j<n-1-i; j++)
        {
            if(array[j]>array[j+1])
            {
                k=array[j];
                array[j]=array[j+1];
                array[j+1]=k;
            }
        }
}
```


python
```python
def bubble_sort(array):
    n = len(array)
    for i in range(n-1):
        for j in range(n-1-i):
            if array[j] > array[j+1]:
                # Swap array[j] and array[j+1]
                array[j], array[j+1] = array[j+1], array[j]

# Example usage:
arr = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(arr)
print("Sorted array is:", arr)
```

- **`n = len(array)`**: Determine the length of the array.
- **Outer loop (`for i in range(n-1)`):**
    - This loop runs `n-1` times. With each iteration, the largest unsorted element "bubbles up" to its correct position.
- **Inner loop (`for j in range(n-1-i)`):**
    - This loop compares adjacent elements and swaps them if they are in the wrong order.
    - As `i` increases, the last `i` elements are already sorted, so the inner loop's range decreases.
- **Swapping (`array[j], array[j+1] = array[j+1], array[j]`):**
    - This is a Pythonic way to swap two elements.

# 3 直接选择排序selectSort

选择排序从小到大排序：
一开始从0~n-1区间上选择一个最小值，将其放在位置0上，
然后在1~n-1范围上选取最小值放在位置1上。
重复过程直到剩下最后一个元素，数组即为有序。

![](https://i-blog.csdnimg.cn/blog_migrate/59830b4f4143b33c530f43a731c3b4b5.gif)

```c
//array[]为待排序数组，n为数组长度
void selectSort(int array[], int n)
{
    int i, j ,min ,k;
    for( i=0; i<n-1; i++)
    {
        min=i; //每趟排序最小值先等于第一个数，遍历剩下的数
        for( j=i+1; j<n; j++) //从i下一个数开始检查
        {
            if(array[min]>array[j])
            {
                min=j;
            }
        }
        if(min!=i)
        {
            k=array[min];
            array[min]=array[i];
            array[i]=k;
        }
    }
}
```


python
```python 
def select_sort(array):
    n = len(array)
    for i in range(n-1):
        min_index = i  # Assume the minimum is the first element
        for j in range(i+1, n):
            if array[min_index] > array[j]:
                min_index = j  # Update the index of the minimum element

        if min_index != i:
            # Swap the found minimum element with the first element of the unsorted part
            array[i], array[min_index] = array[min_index], array[i]

# Example usage:
arr = [64, 25, 12, 22, 11]
select_sort(arr)
print("Sorted array is:", arr)
```

- **`n = len(array)`**: Get the length of the array.
- **Outer loop (`for i in range(n-1)`):**
    - This loop runs `n-1` times. In each iteration, it assumes the element at index `i` is the minimum and tries to find the true minimum in the remaining part of the array.
- **Inner loop (`for j in range(i+1, n)`):**
    - This loop starts from the next element after `i` and searches for the smallest element in the rest of the array.
- **Finding the minimum (`if array[min_index] > array[j]`):**
    - If the current element is smaller than the assumed minimum, update `min_index` to the current element's index.
- **Swapping (`array[i], array[min_index] = array[min_index], array[i]`):**
    - After finding the minimum element in the unsorted part, swap it with the element at the current position `i`.

# 4 直接插入排序insertSort

插入排序从小到大排序：
首先位置1上的数和位置0上的数进行比较，如果位置1上的数大于位置0上的数，将位置0上的数向后移一位，将1插入到0位置，否则不处理。
位置k上的数和之前的数依次进行比较，如果位置K上的数更大，将之前的数向后移位，最后将位置k上的数插入不满足条件点，反之不处理。

![](https://i-blog.csdnimg.cn/blog_migrate/a295078afcc5962e61dd9670a34a06f0.gif)  
![](https://i-blog.csdnimg.cn/blog_migrate/5a4f2895712e1dc29e506654673e9051.png)

```C
//array[]为待排序数组，n为数组长度
void insertSort(int array[], int n)
{
    int i,j,temp;
    for( i=1;i<n;i++)
    {
        if(array[i]<array[i-1])
        {
            temp=array[i];
            for( j=i;array[j-1]>temp;j--)
            {
                array[j]=array[j-1];
            }
            array[j]=temp;
        }
    }
}
```

python
```python
def insert_sort(array):
    n = len(array)
    for i in range(1, n):
        if array[i] < array[i - 1]:
            temp = array[i]
            j = i
            while j > 0 and array[j - 1] > temp:
                array[j] = array[j - 1]
                j -= 1
            array[j] = temp

# Example usage:
arr = [64, 25, 12, 22, 11]
insert_sort(arr)
print("Sorted array is:", arr)
```

- **`n = len(array)`**: Get the length of the array.
- **Outer loop (`for i in range(1, n)`):**
    - This loop starts from the second element and iterates through the array. It assumes that the subarray before the current element is already sorted.
- **Comparison (`if array[i] < array[i - 1]`):**
    - If the current element is smaller than the previous one, it needs to be inserted in the correct position within the sorted part of the array.
- **Inner loop (`while j > 0 and array[j - 1] > temp`):**
    - This loop shifts the elements that are greater than `temp` one position to the right to make room for `temp`.
- **Swapping (`array[j] = temp`):**
    - Place `temp` in its correct position within the sorted portion of the array.


# 5 快速排序quicksort

 快速排序从小到大排序：
 在数组中随机选一个数（默认数组首个元素），数组中小于等于此数的放在左边部分，大于此数的放在右边部分，这个操作确保了这个数是处于正确位置的，
 再对左边部分数组和右边部分数组递归调用快速排序，重复这个过程。

![](https://i-blog.csdnimg.cn/blog_migrate/a5c6a1b560c5a002e1086178fd5e21d2.gif)   
![](https://i-blog.csdnimg.cn/blog_migrate/ed973c5f163bf7c3970b60ee29d365c1.png)


```
void quicksort(int a[], int left, int right) {
    int i, j, t, privotkey;
    if (left > right)   //（递归过程先写结束条件）
        return;
 
    privotkey = a[left]; //temp中存的就是基准数（枢轴）
    i = left;
    j = right;
    while (i < j) {
        //顺序很重要，要先从右边开始找（最后交换基准时换过去的数要保证比基准小，因为基准选取数组第一个数）
        while (a[j] >= privotkey && i < j) {
            j--;
        }
        a[i] = a[j];
        //再找左边的
        while (a[i] <= privotkey && i < j) {
            i++;
        }
        a[j] = a[i];
    }
    //最终将基准数归位
    a[i] = privotkey;
 
    quicksort(a, left, i - 1);//继续处理左边的，这里是一个递归的过程
    quicksort(a, i + 1, right);//继续处理右边的 ，这里是一个递归的过程
}
```


python
```python
def quicksort(a, left, right):
    if left > right:  # Recursion base case: end condition
        return
    
    pivotkey = a[left]  # Choose the pivot element
    i = left
    j = right
    
    while i < j:
        # Start searching from the right side
        while a[j] >= pivotkey and i < j:
            j -= 1
        a[i] = a[j]  # Place the smaller element to the left
        
        # Now search from the left side
        while a[i] <= pivotkey and i < j:
            i += 1
        a[j] = a[i]  # Place the larger element to the right
    
    # Place the pivot element in its correct position
    a[i] = pivotkey
    
    # Recursively sort the left and right parts
    quicksort(a, left, i - 1)  # Left side
    quicksort(a, i + 1, right)  # Right side

# Example usage:
arr = [64, 25, 12, 22, 11]
quicksort(arr, 0, len(arr) - 1)
print("Sorted array is:", arr)
```

- **Base Case (`if left > right`):**
    - This checks whether the left index has surpassed the right index, which would mean that the portion of the array being sorted has one or no elements, and thus, does not need sorting.
- **Choosing the Pivot (`pivotkey = a[left]`):**
    - The pivot is chosen as the first element of the subarray. The `pivotkey` will be used to rearrange the elements.
- **Partitioning Process:**
    - **Right to Left (`while a[j] >= pivotkey and i < j`):**
        - The loop searches from the right to find an element smaller than the pivot.
        - When such an element is found, it is placed at the current `i` position.
    - **Left to Right (`while a[i] <= pivotkey and i < j`):**
        - Similarly, the loop searches from the left to find an element larger than the pivot.
        - When such an element is found, it is placed at the current `j` position.
- **Placing the Pivot in Correct Position (`a[i] = pivotkey`):**
    - After the above partitioning, the pivot is placed in its correct position, so that all elements to the left are smaller and to the right are larger.
- **Recursive Calls:**
    - The function recursively sorts the subarrays to the left and right of the pivot.


# 6 堆排序heapSort 

 堆排序从小到大排序：
 首先将数组元素建成大小为n的大顶堆，堆顶（数组第一个元素）是所有元素中的最大值，将堆顶元素和数组最后一个元素进行交换，
 再将数组除了最后一个数的n-1个元素建立再次建成一个新的大顶堆，再将大顶堆中最顶的元素(即为最大元素) 和数组倒数第二个元素进行交换，重复直至堆大小减为1。

- 注：完全二叉树   
    假设二叉树深度为n，除了第n层外，n-1层节点都有两个孩子，第n层节点连续从左到右。如下图   
    ![这里写图片描述](https://i-blog.csdnimg.cn/blog_migrate/6ef50972c09bc7c0bb97921d9aecf171.png)
    
- 注：大顶堆   
    大顶堆是具有以下性质的完全二叉树：每个节点的值都大于或等于其左右孩子节点的值。   
    即，根节点是堆中最大的值，按照层序遍历给节点从1开始编号，则节点之间满足如下关系：   
    ![这里写图片描述](https://i-blog.csdnimg.cn/blog_migrate/7c09280a48fd00478e3ff85ab8870632.gif) (1<=i<=n/2)

![](https://i-blog.csdnimg.cn/blog_migrate/441011efb2356a82d709779c893fefe2.gif)   
![](https://i-blog.csdnimg.cn/blog_migrate/1996900264c24b19195aa3e54b217df3.gif)   
![](https://i-blog.csdnimg.cn/blog_migrate/ea11ffe2e9e6724ef293b9f0be28247d.gif)


---

![这里写图片描述](https://i-blog.csdnimg.cn/blog_migrate/f6dc51a3f43eb8d76ddea3dd49c53067.png)


```c
void heapSort(int array[], int n)
{
    int i;
    for (i=n/2;i>0;i--)
    {
        HeapAdjust(array,i,n);//从下向上，从右向左调整
    }
    for( i=n;i>1;i--)
    {
        swap(array, 1, i);
        HeapAdjust(array, 1, i-1);//从上到下，从左向右调整
    }
}
void HeapAdjust(int array[], int s, int n )
{
    int i,temp;
    temp = array[s];
    for(i=2*s;i<=n;i*=2)
    {
        if(i<n&&array[i]<array[i+1])
        {
            i++;
        }
        if(temp>=array[i])
        {
            break;
        }
        array[s]=array[i];
        s=i;
    }
    array[s]=temp;
}
void swap(int array[], int i, int j)
{
    int temp;
 
    temp=array[i];
    array[i]=array[j];
    array[j]=temp;
}
```



python
```python
def heap_sort(array):
    n = len(array)
    
    # Build the heap (rearrange the array)
    for i in range(n // 2 - 1, -1, -1):
        heap_adjust(array, i, n)
    
    # Extract elements one by one
    for i in range(n - 1, 0, -1):
        # Move current root to end
        swap(array, 0, i)
        # Call max heapify on the reduced heap
        heap_adjust(array, 0, i)

def heap_adjust(array, s, n):
    temp = array[s]
    i = 2 * s + 1  # Left child index
    while i < n:
        # If the right child exists and is greater than the left child
        if i + 1 < n and array[i] < array[i + 1]:
            i += 1
        # If the largest child is greater than the root
        if temp >= array[i]:
            break
        array[s] = array[i]
        s = i
        i = 2 * s + 1
    array[s] = temp

def swap(array, i, j):
    array[i], array[j] = array[j], array[i]

# Example usage:
arr = [64, 25, 12, 22, 11]
heap_sort(arr)
print("Sorted array is:", arr)

```


- **Building the Heap (`heap_sort` function):**
    - The array is first transformed into a max heap, meaning each parent node is greater than or equal to its children.
    - The process starts from the last non-leaf node (which is at index `n//2 - 1`) and adjusts the heap using `heap_adjust`.
- **Heap Adjustment (`heap_adjust` function):**
    - This function ensures that the subtree rooted at index `s` is a max heap.
    - It repeatedly moves the largest of the children to the root position and adjusts the subtree.
- **Swapping Elements (`swap` function):**
    - The root of the heap (the largest element) is swapped with the last element of the heap.
    - The heap size is then reduced by 1, and the heap is adjusted again to maintain the max heap property.
- **Extracting Elements:**
    - After building the initial max heap, the largest element is repeatedly swapped to the end of the array, and the heap size is reduced each time.

The line for i in range(n // 2 - 1, -1, -1): in Python is a loop that iterates over a specific range of indices in reverse order. Let's break it down:

```
1. n // 2 - 1 (Start of the Range)
    This expression calculates the starting point of the loop.
    n // 2 gives the index of the middle of the array (using integer division).
    Subtracting 1 (n // 2 - 1) gives the index of the last non-leaf node in a heap (since in a 0-based index array, the last parent node is at n//2 - 1).

2. -1 (End of the Range, Exclusive)
    This is the endpoint of the loop, exclusive. The loop will stop before reaching this value.
    By setting it to -1, the loop will include 0 and stop just before -1.

3. -1 (Step)
    This specifies the step or decrement. Here, -1 means the loop will move from right to left, or from the starting point down to 0.
    It effectively causes the loop to count backwards.


```

Overall Effect:
    The loop starts at the index n // 2 - 1 (the last non-leaf node in a heap).
    It decrements by 1 each time.
    The loop continues until it reaches 0.



# 7 希尔排序`ShellSort`

 希尔排序是插入排序改良的算法，希尔排序步长从大到小调整，第一次循环后面元素逐个和前面元素按间隔步长进行比较并交换，直至步长为1，步长选择是关键。

![这里写图片描述](https://i-blog.csdnimg.cn/blog_migrate/e709597933ce8cbc9110b9adff3f103a.gif)

![](https://i-blog.csdnimg.cn/blog_migrate/262a815e0e07c4eb2ecb3fb9dbb6ec06.png)

```
//下面是插入排序
void InsertSort( int array[], int n)
{
    int i,j,temp;
    for( i=0;i<n;i++ )
    {
        if(array[i]<array[i-1])
        {
            temp=array[i];
            for( j=i-1;array[j]>temp;j--)
            {
                array[j+1]=array[j];
            }
            array[j+1]=temp;
        }
    }
}

//在插入排序基础上修改得到希尔排序
void SheelSort( int array[], int n)
{
    int i,j,temp;
    int gap=n; //~~~~~~~~~~~~~~~~~~~~~
    do{
        gap=gap/3+1;  //~~~~~~~~~~~~~~~~~~
        for( i=gap;i<n;i++ )
        {
            if(array[i]<array[i-gap])
            {
                temp=array[i];
                for( j=i-gap;array[j]>temp;j-=gap)
                {
                    array[j+gap]=array[j];
                }
                array[j+gap]=temp;
            }
        }
    }while(gap>1);  //~~~~~~~~~~~~~~~~~~~~~~
 
}
```



python
```python
def shell_sort(array):
    n = len(array)
    gap = n  # Initialize gap size
    while gap > 1:
        gap = gap // 3 + 1  # Reduce the gap size
        for i in range(gap, n):  # Start sorting from the gap index
            if array[i] < array[i - gap]:
                temp = array[i]
                j = i - gap
                while j >= 0 and array[j] > temp:
                    array[j + gap] = array[j]
                    j -= gap
                array[j + gap] = temp

# Example usage:
arr = [64, 25, 12, 22, 11]
shell_sort(arr)
print("Sorted array using Shell Sort is:", arr)
```


- **Gap:** It starts with a large gap between elements and reduces it over time.
- **Sorting with Gap:** It performs a gapped insertion sort, which allows elements to be moved quickly towards their correct position.
- The gap is reduced gradually, and the array is sorted with decreasing gaps until the gap is 1 (at which point it becomes a regular insertion sort).

# 8 归并排序MergeSort

 归并排序从小到大排序：首先让数组中的每一个数单独成为长度为1的区间，然后两两一组有序合并，得到长度为2的有序区间，依次进行，直到合成整个区间。

![](https://i-blog.csdnimg.cn/blog_migrate/c64f25d32e15a1cf85b94b6c292eec45.gif)


递归实现 
```
实现归并，并把数据都放在list1里面 
void merging(int *list1, int list1_size, int *list2,  int list2_size)
{
    int i=0, j=0, k=0, m=0;
    int temp[MAXSIZE];
 
    while(i < list1_size && j < list2_size)
    {
        if(list1[i]<list2[j])
        {
            temp[k++] = list1[i++];
        }
        else
        {
            temp[k++] = list2[j++];
        }
    }
    while(i<list1_size)
    {
        temp[k++] = list1[i++];
    }
    while(j<list2_size)
    {
        temp[k++] = list2[j++];
    }
 
    for(m=0; m < (list1_size+list2_size); m++)
    {
        list1[m]=temp[m];
    }
}
//如果有剩下的，那么说明就是它是比前面的数组都大的，直接加入就可以了 
void mergeSort(int array[], int n)
{
    if(n>1)
    {
        int *list1 = array;
        int list1_size = n/2;
        int *list2 = array + n/2;
        int list2_size = n-list1_size;
 
        mergeSort(list1, list1_size);
        mergeSort(list2, list2_size);
 
        merging(list1, list1_size, list2, list2_size);
    }
}
//归并排序复杂度分析：一趟归并需要将待排序列中的所有记录  
//扫描一遍，因此耗费时间为O(n),而由完全二叉树的深度可知，  
//整个归并排序需要进行[log2n],因此，总的时间复杂度为  
//O(nlogn),而且这是归并排序算法中平均的时间性能  
//空间复杂度：由于归并过程中需要与原始记录序列同样数量级的  
//存储空间去存放归并结果及递归深度为log2N的栈空间，因此空间  
//复杂度为O(n+logN)  
//也就是说，归并排序是一种比较占内存，但却效率高且稳定的算法 
```

迭代实现 
```
void MergeSort(int k[],int n)  
{  
    int i,next,left_min,left_max,right_min,right_max;  
    //动态申请一个与原来数组一样大小的空间用来存储
    int *temp = (int *)malloc(n * sizeof(int));  
    //逐级上升，第一次比较2个，第二次比较4个，第三次比较8个。。。  
    for(i=1; i<n; i*=2)  
    {  
        //每次都从0开始，数组的头元素开始  
        for(left_min=0; left_min<n-i; left_min = right_max)  
        {  
            right_min = left_max = left_min + i;  
            right_max = left_max + i;  
            //右边的下标最大值只能为n  
            if(right_max>n)  
            {  
                right_max = n;  
            }  
            //next是用来标志temp数组下标的，由于每次数据都有返回到K，  
            //故每次开始得重新置零  
            next = 0;  
            //如果左边的数据还没达到分割线且右边的数组没到达分割线，开始循环  
            while(left_min<left_max&&right_min<right_max)  
            {  
                if(k[left_min] < k[right_min])  
                {  
                    temp[next++] = k[left_min++];  
                }  
                else  
                {  
                    temp[next++] = k[right_min++];  
                }  
            }  
            //上面循环结束的条件有两个，如果是左边的游标尚未到达，那么需要把  
            //数组接回去，可能会有疑问，那如果右边的没到达呢，其实模拟一下就可以  
            //知道，如果右边没到达，那么说明右边的数据比较大，这时也就不用移动位置了  
 
            while(left_min < left_max)  
            {  
                //如果left_min小于left_max，说明现在左边的数据比较大  
                //直接把它们接到数组的min之前就行  
                k[--right_min] = k[--left_max];   
            }  
            while(next>0)  
            {  
                //把排好序的那部分数组返回该k  
                k[--right_min] = temp[--next];        
            }  
        }  
    }  
}  
//非递归的方法，避免了递归时深度为log2N的栈空间，
//空间只是用到归并临时申请的跟原来数组一样大小的空间，并且在时间性能上也有一定的提升，
//因此，使用归并排序是，尽量考虑用非递归的方法。
```