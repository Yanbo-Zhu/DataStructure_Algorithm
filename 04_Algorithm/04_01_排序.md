
https://blog.csdn.net/pange1991/article/details/85460755
https://www.cxyxiaowu.com/20156.html
# 1 分类 

![这里写图片描述](https://i-blog.csdnimg.cn/blog_migrate/9f21dcc6818c7a7f9b196f5ce44aba26.jpeg)


1 内排序和外排序。
放在内存的称为内排序，需要使用外存的称为外排序。


2 基于排序的算法 和非基于排序的算法
基于排序的算法: 直接选择排序, 堆排序, 直接插入排序, 希尔排序, 冒泡排序, 快速排序, 计数排序, 基数排序 
非基于排序的算法: 多路归并, 败者树


3 基于递归的算法和基于迭代的算法
基于递归的算法 归并排序, 快速排序, 随机快速排序
基于迭代的算法: 冒泡排序, 选择排序, 插入排序, 计数排序, 基数排序


4 稳定的排序
插入排序，冒泡排序，归并排序，计数排序都是稳定的排序，而其他排序则是不稳定的。


# 2 排序算法的[时间复杂度](https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&spm=1001.2101.3001.7020)和空间复杂度

|            |                 |             |             |             |           |         |
| ---------- | --------------- | ----------- | ----------- | ----------- | --------- | ------- |
| **排序算法**   | 英文              | **平均时间复杂度** | **最坏时间复杂度** | **最好时间复杂度** | **空间复杂度** | **稳定性** |
| **冒泡排序**   | BubbleSort      | O(n²)       | O(n²)       | O(n)        | O(1)      | 稳定      |
| **直接选择排序** | SelectSort      | O(n²)       | O(n²)       | O(n)        | O(1)      | 不稳定     |
| **直接插入排序** | InsertSort      | O(n²)       | O(n²)       | O(n)        | O(1)      | 稳定      |
| **快速排序**   | QuickSort       | O(nlogn)    | O(n²)       | O(nlogn)    | O(nlogn)  | 不稳定     |
| 随机快速排序     | RandomQuickSort |             |             |             |           |         |
| **堆排序**    | HeapSort        | O(nlogn)    | O(nlogn)    | O(nlogn)    | O(1)      | 不稳定     |
| **希尔排序**   | ShellSort       | O(nlogn)    | O(ns)       | O(n)        | O(1)      | 不稳定     |
| **归并排序**   | MergeSort       | O(nlogn)    | O(nlogn)    | O(nlogn)    | O(n)      | 稳定      |
| **计数排序**   | CountSort       | O(n+k)      | O(n+k)      | O(n+k)      | O(n+k)    | 稳定      |
| **基数排序**   | Rad             | O(N*M)      | O(N*M)      | O(N*M)      | O(M)      | 稳定      |


**注**：
1 归并排序可以通过手摇算法将[空间复杂度](https://so.csdn.net/so/search?q=%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&spm=1001.2101.3001.7020)降到O(1)，但是时间复杂度会提高。
2 基数排序时间复杂度为O(N*M)，其中N为数据个数，M为数据位数。

**辅助记忆**

时间复杂度记忆
1. 冒泡、选择、直接 排序需要两个for循环，每次只关注一个元素，平均时间复杂度为O(n²)）（一遍找元素O(n)，一遍找位置O(n)）
2. 快速、归并、希尔、堆基于二分思想，log以2为底，平均时间复杂度为O(nlogn)（一遍找元素O(n)，一遍找位置O(logn)）

稳定性记忆-“快希选堆”（快牺牲稳定性） 
1. 排序算法的稳定性：排序前后相同元素的相对位置不变，则称排序算法是稳定的；否则排序算法是不稳定的。


# 3 冒泡排序BubbleSort


|          |             |             |             |           |         |
| -------- | ----------- | ----------- | ----------- | --------- | ------- |
| **排序算法** | **平均时间复杂度** | **最坏时间复杂度** | **最好时间复杂度** | **空间复杂度** | **稳定性** |
| **冒泡排序** | O(n²)       | O(n²)       | O(n)        | O(1)      | 稳定      |


冒泡排序时间复杂度跟选择排序相同。其思想就是进行 n-1 趟排序，每次都是把最大的数上浮，像鱼冒泡一样。最坏情况为 O(N^2)。代码如下：


冒泡排序从小到大排序：
一开始交换的区间为0~N-1，将第1个数和第2个数进行比较，前面大于后面，交换两个数，否则不交换。再比较第2个数和第三个数，前面大于后面，交换两个数否则不交换。依次进行，最大的数会放在数组最后的位置。
然后将范围变为0~N-2，数组第二大的数会放在数组倒数第二的位置。
依次进行整个交换过程，最后范围只剩一个数时数组即为有序。

![](https://i-blog.csdnimg.cn/blog_migrate/ec52b59618c639c3e3c1e0967eeee674.gif)

最好时间复杂度: 
在上面显示的小型升序排序示例 [3, 6, 11, 25, 39]中，Bubble Sort可以在O(N)时间内终止。
改进的想法很简单：如果我们在内循环中没有交换，那就意味着数组已经排序，我们可以在那个点停止冒泡排序。

```c++
//array[]为待排序数组，n为数组长度
void BubbleSort(int array[], int n)
{
    int i, j, k;
    for(i=0; i<n-1; i++)
        for(j=0; j<n-1-i; j++)
        {
            if(array[j]>array[j+1])
            {
                k=array[j];
                array[j]=array[j+1];
                array[j+1]=k;
            }
        }
}
```


python
```python
def bubble_sort(array):
    n = len(array)
    for i in range(n-1):
        for j in range(n-1-i):
            if array[j] > array[j+1]:
                # Swap array[j] and array[j+1]
                array[j], array[j+1] = array[j+1], array[j]

# Example usage:
arr = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(arr)
print("Sorted array is:", arr)
```

- **`n = len(array)`**: Determine the length of the array.
- **Outer loop (`for i in range(n-1)`):**
    - This loop runs `n-1` times. With each iteration, the largest unsorted element "bubbles up" to its correct position.
- **Inner loop (`for j in range(n-1-i)`):**
    - This loop compares adjacent elements and swaps them if they are in the wrong order.
    - As `i` increases, the last `i` elements are already sorted, so the inner loop's range decreases.
- **Swapping (`array[j], array[j+1] = array[j+1], array[j]`):**
    - This is a Pythonic way to swap two elements.


---
优化版 
对冒泡排序的一个改进就是在每趟排序时判断是否发生交换，如果一次交换都没有发生，则数组已经有序，可以不用继续剩下的趟数直接退出。改进后代码如下：

```c
/**
 * 冒泡排序-优化版
 */
void betterBubbleSort(int a[], int n)
{
    int tmp, i, j;
    for (i = 0; i < n; i++) {
        int sorted = 1;
        for (j = n-1; j >= i+1; j--) {
            if (a[j] < a[j-1]) {
                tmp = a[j], a[j] = a[j-1], a[j-1] = tmp;
                sorted = 0;
            }   
        }   
        if (sorted)
            return ;
    }   
}
```


```python
def better_bubble_sort(a):
    n = len(a)
    
    for i in range(n):
        # Assume the array is already sorted
        sorted = True
        
        # Perform a single pass of bubble sort
        for j in range(n-1, i, -1):
            if a[j] < a[j-1]:
                # Swap elements if they're in the wrong order
                a[j], a[j-1] = a[j-1], a[j]
                sorted = False
        
        # If no swaps were made, the array is already sorted
        if sorted:
            break

# Example usage:
if __name__ == "__main__":
    a = [64, 34, 25, 12, 22, 11, 90]
    better_bubble_sort(a)
    print(a)  # Output should be [11, 12, 22, 25, 34, 64, 90]
```


# 4 选择排序selectSort

|          |            |             |             |             |           |         |
| -------- | ---------- | ----------- | ----------- | ----------- | --------- | ------- |
| **排序算法** | 英文         | **平均时间复杂度** | **最坏时间复杂度** | **最好时间复杂度** | **空间复杂度** | **稳定性** |
| 选择排序     | SelectSort | O(n²)       | O(n²)       | O(n)        | O(1)      | 不稳定     |
|          |            |             |             |             |           |         |


选择排序的思想就是第i次选取第i小的元素放在位置i。比如第1次就选择最小的元素放在位置0，第2次选择第二小的元素放在位置1。

选择排序最好和最坏时间复杂度都为 O(N^2)。

选择排序从小到大排序：
一开始从0~n-1区间上选择一个最小值，将其放在位置0上，
然后在1~n-1范围上选取最小值放在位置1上。
重复过程直到剩下最后一个元素，数组即为有序。

![](https://i-blog.csdnimg.cn/blog_migrate/59830b4f4143b33c530f43a731c3b4b5.gif)

```c
//array[]为待排序数组，n为数组长度
void selectSort(int array[], int n)
{
    int i, j ,min ,k;
    for( i=0; i<n-1; i++)
    {
        min=i; //每趟排序最小值先等于第一个数，遍历剩下的数
        for( j=i+1; j<n; j++) //从i下一个数开始检查
        {
            if(array[min]>array[j])
            {
                min=j;
            }
        }
        if(min!=i)
        {
            k=array[min];
            array[min]=array[i];
            array[i]=k;
        }
    }
}
```

**循环不变式：在外层循环执行前，a[0…i-1]包含 a 中最小的 i 个数，且有序。**
- 初始时，i=0，a[0…-1] 为空，显然成立。
- 每次执行完成后，a[0…i] 包含 a 中最小的 i+1 个数，且有序。即第一次执行完成后，a[0…0] 包含 a 最小的 1 个数，且有序。
- 循环结束后，i=n-1，则 a[0…n-2]包含 a 最小的 n-1 个数，且已经有序。所以整个数组有序。

python
```python 
def select_sort(array):
    n = len(array)
    for i in range(n-1):
        min_index = i  # Assume the minimum is the first element
        for j in range(i+1, n):
            if array[min_index] > array[j]:
                min_index = j  # Update the index of the minimum element

        if min_index != i:
            # Swap the found minimum element with the first element of the unsorted part
            array[i], array[min_index] = array[min_index], array[i]

# Example usage:
arr = [64, 25, 12, 22, 11]
select_sort(arr)
print("Sorted array is:", arr)
```

- **`n = len(array)`**: Get the length of the array.
- **Outer loop (`for i in range(n-1)`):**
    - This loop runs `n-1` times. In each iteration, it assumes the element at index `i` is the minimum and tries to find the true minimum in the remaining part of the array.
- **Inner loop (`for j in range(i+1, n)`):**
    - This loop starts from the next element after `i` and searches for the smallest element in the rest of the array.
- **Finding the minimum (`if array[min_index] > array[j]`):**
    - If the current element is smaller than the assumed minimum, update `min_index` to the current element's index.
- **Swapping (`array[i], array[min_index] = array[min_index], array[i]`):**
    - After finding the minimum element in the unsorted part, swap it with the element at the current position `i`.

# 5 插入排序insertSort

|          |            |             |             |             |           |         |
| -------- | ---------- | ----------- | ----------- | ----------- | --------- | ------- |
| **排序算法** | 英文         | **平均时间复杂度** | **最坏时间复杂度** | **最好时间复杂度** | **空间复杂度** | **稳定性** |
| 插入排序**   | InsertSort | O(n²)       | O(n²)       | O(n)        | O(1)      | 稳定      |

插入排序从小到大排序：
首先位置1上的数和位置0上的数进行比较，如果位置1上的数大于位置0上的数，将位置0上的数向后移一位，将1插入到0位置，否则不处理。
位置k上的数和之前的数依次进行比较，如果位置K上的数更大，将之前的数向后移位，最后将位置k上的数插入不满足条件点，反之不处理。

![](https://i-blog.csdnimg.cn/blog_migrate/a295078afcc5962e61dd9670a34a06f0.gif)  
![](https://i-blog.csdnimg.cn/blog_migrate/5a4f2895712e1dc29e506654673e9051.png)

```C
//array[]为待排序数组，n为数组长度
void insertSort(int array[], int n)
{
    int i,j,temp;
    for( i=1;i<n;i++)
    {
        if(array[i]<array[i-1])
        {
            temp=array[i];
            for( j=i;array[j-1]>temp;j--)
            {
                array[j]=array[j-1];
            }
            array[j]=temp;
        }
    }
}
```

python
```python
def insert_sort(array):
    n = len(array)
    for i in range(1, n):
        if array[i] < array[i - 1]:
            temp = array[i]
            j = i
            while j > 0 and array[j - 1] > temp:
                array[j] = array[j - 1]
                j -= 1
            array[j] = temp

# Example usage:
arr = [64, 25, 12, 22, 11]
insert_sort(arr)
print("Sorted array is:", arr)
```

- **`n = len(array)`**: Get the length of the array.
- **Outer loop (`for i in range(1, n)`):**
    - This loop starts from the second element and iterates through the array. It assumes that the subarray before the current element is already sorted.
- **Comparison (`if array[i] < array[i - 1]`):**
    - If the current element is smaller than the previous one, it needs to be inserted in the correct position within the sorted part of the array.
- **Inner loop (`while j > 0 and array[j - 1] > temp`):**
    - This loop shifts the elements that are greater than `temp` one position to the right to make room for `temp`.
- **Swapping (`array[j] = temp`):**
    - Place `temp` in its correct position within the sorted portion of the array.


# 6 快速排序quickSort

https://www.cxyxiaowu.com/20154.html

|          |           |             |             |             |           |         |
| -------- | --------- | ----------- | ----------- | ----------- | --------- | ------- |
| **排序算法** | 英文        | **平均时间复杂度** | **最坏时间复杂度** | **最好时间复杂度** | **空间复杂度** | **稳定性** |
| **快速排序** | QuickSort | O(nlogn)    | O(n²)       | O(nlogn)    | O(nlogn)  | 不稳定     |

- **划分**：数组 A[p…r] 被划分为两个子数组 A[p…q-1] 和 A[q+1…r]，使得 A[p…q-1] 中每个元素都小于等于 A[q]，而 A[q+1…r] 每个元素都大于 A[q]。划分流程见下图。
- **解决**：通过递归调用快速排序，对子数组分别排序即可。
- **合并**：因为两个子数组都已经排好序了，且已经有大小关系了，不需要做任何操作。

 快速排序从小到大排序：
 在数组中随机选一个数（默认数组首个元素），数组中小于等于此数的放在左边部分，大于此数的放在右边部分，这个操作确保了这个数是处于正确位置的，
 再对左边部分数组和右边部分数组递归调用快速排序，重复这个过程。

![](https://i-blog.csdnimg.cn/blog_migrate/a5c6a1b560c5a002e1086178fd5e21d2.gif)   
![](https://i-blog.csdnimg.cn/blog_migrate/ed973c5f163bf7c3970b60ee29d365c1.png)


```
void quicksort(int a[], int left, int right) {
    int i, j, t, privotkey;
    if (left > right)   //（递归过程先写结束条件）
        return;
 
    privotkey = a[left]; //temp中存的就是基准数（枢轴）
    i = left;
    j = right;
    while (i < j) {
        //顺序很重要，要先从右边开始找（最后交换基准时换过去的数要保证比基准小，因为基准选取数组第一个数）
        while (a[j] >= privotkey && i < j) {
            j--;
        }
        a[i] = a[j];
        //再找左边的
        while (a[i] <= privotkey && i < j) {
            i++;
        }
        a[j] = a[i];
    }
    //最终将基准数归位
    a[i] = privotkey;
 
    quicksort(a, left, i - 1);//继续处理左边的，这里是一个递归的过程
    quicksort(a, i + 1, right);//继续处理右边的 ，这里是一个递归的过程
}
```


python
```python
def quicksort(a, left, right):
    if left > right:  # Recursion base case: end condition
        return
    
    pivotkey = a[left]  # Choose the pivot element
    i = left
    j = right
    
    while i < j:
        # Start searching from the right side
        while a[j] >= pivotkey and i < j:
            j -= 1
        a[i] = a[j]  # Place the smaller element to the left
        
        # Now search from the left side
        while a[i] <= pivotkey and i < j:
            i += 1
        a[j] = a[i]  # Place the larger element to the right
    
    # Place the pivot element in its correct position
    a[i] = pivotkey
    
    # Recursively sort the left and right parts
    quicksort(a, left, i - 1)  # Left side
    quicksort(a, i + 1, right)  # Right side

# Example usage:
arr = [64, 25, 12, 22, 11]
quicksort(arr, 0, len(arr) - 1)
print("Sorted array is:", arr)
```

- **Base Case (`if left > right`):**
    - This checks whether the left index has surpassed the right index, which would mean that the portion of the array being sorted has one or no elements, and thus, does not need sorting.
- **Choosing the Pivot (`pivotkey = a[left]`):**
    - The pivot is chosen as the first element of the subarray. The `pivotkey` will be used to rearrange the elements.
- **Partitioning Process:**
    - **Right to Left (`while a[j] >= pivotkey and i < j`):**
        - The loop searches from the right to find an element smaller than the pivot.
        - When such an element is found, it is placed at the current `i` position.
    - **Left to Right (`while a[i] <= pivotkey and i < j`):**
        - Similarly, the loop searches from the left to find an element larger than the pivot.
        - When such an element is found, it is placed at the current `j` position.
- **Placing the Pivot in Correct Position (`a[i] = pivotkey`):**
    - After the above partitioning, the pivot is placed in its correct position, so that all elements to the left are smaller and to the right are larger.
- **Recursive Calls:**
    - The function recursively sorts the subarrays to the left and right of the pivot.


## 6.1 朴素的快速排序


这个朴素的快速排序有个缺陷就是在一些极端情况如所有元素都相等时（或者元素本身有序，如 a[] = {1,2,3,4,5}等），朴素的快速算法时间复杂度为 O(N^2)，而如果能够平衡划分数组则时间复杂度为 O(NlgN)。

```python
/**
 * 快速排序-朴素版本
 */
void quickSort(int a[], int l, int u)
{
    if (l >= u) return;
    int q = partition(a, l, u);
    quickSort(a, l, q-1);
    quickSort(a, q+1, u);
}

/**
 * 快速排序-划分函数
 */
int partition(int a[], int l, int u)
{
    int i, q=l;
    for (i = l+1; i <= u; i++) {
        if (a[i] < a[l])
            swapInt(a, i, ++q);
    }
    swapInt(a, l, q);
    return q;
}
```

```python
def quick_sort(a, l, u):
    if l >= u:
        return
    q = partition(a, l, u)
    quick_sort(a, l, q - 1)
    quick_sort(a, q + 1, u)

def partition(a, l, u):
    pivot = a[l]
    q = l
    for i in range(l + 1, u + 1):
        if a[i] < pivot:
            q += 1
            a[i], a[q] = a[q], a[i]  # Swap elements
    a[l], a[q] = a[q], a[l]  # Swap pivot element with the partition element
    return q

# Example usage:
if __name__ == "__main__":
    a = [10, 7, 8, 9, 1, 5]
    quick_sort(a, 0, len(a) - 1)
    print("Sorted array is:", a)  # Output should be [1, 5, 7, 8, 9, 10]
```

- **`quick_sort(a, l, u)` Function**:
    - **Base Case**: The recursion terminates when `l >= u`, meaning the subarray has one or zero elements.
    - **Recursive Case**: The array is partitioned around a pivot element, and the function recursively sorts the two subarrays (`a[l..q-1]` and `a[q+1..u]`).
- **`partition(a, l, u)` Function**:
    - **Pivot Selection**: The pivot element is selected as the first element of the subarray `a[l]`.
    - **Partition Process**:
        - The function scans the subarray from `l+1` to `u`.
        - It maintains a pointer `q` which separates elements less than the pivot from those greater than or equal to it.
        - For each element that is less than the pivot, it increments `q` and swaps the element with the one at `q`.
    - **Final Swap**: After the loop, the pivot element is swapped with the element at `q`, which places the pivot in its correct sorted position.
    - **Return**: The function returns `q`, the index of the pivot element after partitioning.
- **Example Usage**:
    - The example initializes an unsorted array `a = [10, 7, 8, 9, 1, 5]` and applies the `quick_sort` function to sort it. The output will be `[1, 5, 7, 8, 9, 10]`.







# 7 堆排序heapSort 


|            |                 |             |             |             |           |         |
| ---------- | --------------- | ----------- | ----------- | ----------- | --------- | ------- |
| **排序算法**   | 英文              | **平均时间复杂度** | **最坏时间复杂度** | **最好时间复杂度** | **空间复杂度** | **稳定性** |
| **冒泡排序**   | BubbleSort      | O(n²)       | O(n²)       | O(n)        | O(1)      | 稳定      |
| **直接选择排序** | SelectSort      | O(n²)       | O(n²)       | O(n)        | O(1)      | 不稳定     |
| **直接插入排序** | InsertSort      | O(n²)       | O(n²)       | O(n)        | O(1)      | 稳定      |
| **快速排序**   | QuickSort       | O(nlogn)    | O(n²)       | O(nlogn)    | O(nlogn)  | 不稳定     |
| 随机快速排序     | RandomQuickSort |             |             |             |           |         |
| **堆排序**    | HeapSort        | O(nlogn)    | O(nlogn)    | O(nlogn)    | O(1)      | 不稳定     |
| **希尔排序**   | ShellSort       | O(nlogn)    | O(ns)       | O(n)        | O(1)      | 不稳定     |
| **归并排序**   | MergeSort       | O(nlogn)    | O(nlogn)    | O(nlogn)    | O(n)      | 稳定      |
| **计数排序**   | CountSort       | O(n+k)      | O(n+k)      | O(n+k)      | O(n+k)    | 稳定      |
| **基数排序**   | Rad             | O(N*M)      | O(N*M)      | O(N*M)      | O(M)      | 稳定      |


 堆排序从小到大排序：
 首先将数组元素建成大小为n的大顶堆，堆顶（数组第一个元素）是所有元素中的最大值，将堆顶元素和数组最后一个元素进行交换，
 再将数组除了最后一个数的n-1个元素建立再次建成一个新的大顶堆，再将大顶堆中最顶的元素(即为最大元素) 和数组倒数第二个元素进行交换，重复直至堆大小减为1。

- 注：完全二叉树   
    假设二叉树深度为n，除了第n层外，n-1层节点都有两个孩子，第n层节点连续从左到右。如下图   
    ![这里写图片描述](https://i-blog.csdnimg.cn/blog_migrate/6ef50972c09bc7c0bb97921d9aecf171.png)
    
- 注：大顶堆   
    大顶堆是具有以下性质的完全二叉树：每个节点的值都大于或等于其左右孩子节点的值。   
    即，根节点是堆中最大的值，按照层序遍历给节点从1开始编号，则节点之间满足如下关系：   
    ![这里写图片描述](https://i-blog.csdnimg.cn/blog_migrate/7c09280a48fd00478e3ff85ab8870632.gif) (1<=i<=n/2)

![](https://i-blog.csdnimg.cn/blog_migrate/441011efb2356a82d709779c893fefe2.gif)   
![](https://i-blog.csdnimg.cn/blog_migrate/1996900264c24b19195aa3e54b217df3.gif)   
![](https://i-blog.csdnimg.cn/blog_migrate/ea11ffe2e9e6724ef293b9f0be28247d.gif)


---

![这里写图片描述](https://i-blog.csdnimg.cn/blog_migrate/f6dc51a3f43eb8d76ddea3dd49c53067.png)


```c
void heapSort(int array[], int n)
{
    int i;
    for (i=n/2;i>0;i--)
    {
        HeapAdjust(array,i,n);//从下向上，从右向左调整
    }
    for( i=n;i>1;i--)
    {
        swap(array, 1, i);
        HeapAdjust(array, 1, i-1);//从上到下，从左向右调整
    }
}
void HeapAdjust(int array[], int s, int n )
{
    int i,temp;
    temp = array[s];
    for(i=2*s;i<=n;i*=2)
    {
        if(i<n&&array[i]<array[i+1])
        {
            i++;
        }
        if(temp>=array[i])
        {
            break;
        }
        array[s]=array[i];
        s=i;
    }
    array[s]=temp;
}
void swap(int array[], int i, int j)
{
    int temp;
 
    temp=array[i];
    array[i]=array[j];
    array[j]=temp;
}
```



python
```python
def heap_sort(array):
    n = len(array)
    
    # Build the heap (rearrange the array)
    for i in range(n // 2 - 1, -1, -1):
        heap_adjust(array, i, n)
    
    # Extract elements one by one
    for i in range(n - 1, 0, -1):
        # Move current root to end
        swap(array, 0, i)
        # Call max heapify on the reduced heap
        heap_adjust(array, 0, i)

def heap_adjust(array, s, n):
    temp = array[s]
    i = 2 * s + 1  # Left child index
    while i < n:
        # If the right child exists and is greater than the left child
        if i + 1 < n and array[i] < array[i + 1]:
            i += 1
        # If the largest child is greater than the root
        if temp >= array[i]:
            break
        array[s] = array[i]
        s = i
        i = 2 * s + 1
    array[s] = temp

def swap(array, i, j):
    array[i], array[j] = array[j], array[i]

# Example usage:
arr = [64, 25, 12, 22, 11]
heap_sort(arr)
print("Sorted array is:", arr)

```


- **Building the Heap (`heap_sort` function):**
    - The array is first transformed into a max heap, meaning each parent node is greater than or equal to its children.
    - The process starts from the last non-leaf node (which is at index `n//2 - 1`) and adjusts the heap using `heap_adjust`.
- **Heap Adjustment (`heap_adjust` function):**
    - This function ensures that the subtree rooted at index `s` is a max heap.
    - It repeatedly moves the largest of the children to the root position and adjusts the subtree.
- **Swapping Elements (`swap` function):**
    - The root of the heap (the largest element) is swapped with the last element of the heap.
    - The heap size is then reduced by 1, and the heap is adjusted again to maintain the max heap property.
- **Extracting Elements:**
    - After building the initial max heap, the largest element is repeatedly swapped to the end of the array, and the heap size is reduced each time.

The line for i in range(n // 2 - 1, -1, -1): in Python is a loop that iterates over a specific range of indices in reverse order. Let's break it down:

```
1. n // 2 - 1 (Start of the Range)
    This expression calculates the starting point of the loop.
    n // 2 gives the index of the middle of the array (using integer division).
    Subtracting 1 (n // 2 - 1) gives the index of the last non-leaf node in a heap (since in a 0-based index array, the last parent node is at n//2 - 1).

2. -1 (End of the Range, Exclusive)
    This is the endpoint of the loop, exclusive. The loop will stop before reaching this value.
    By setting it to -1, the loop will include 0 and stop just before -1.

3. -1 (Step)
    This specifies the step or decrement. Here, -1 means the loop will move from right to left, or from the starting point down to 0.
    It effectively causes the loop to count backwards.


```

Overall Effect:
    The loop starts at the index n // 2 - 1 (the last non-leaf node in a heap).
    It decrements by 1 each time.
    The loop continues until it reaches 0.



 8 希尔排序`ShellSort`


|          |           |             |             |             |           |         |
| -------- | --------- | ----------- | ----------- | ----------- | --------- | ------- |
| **排序算法** | 英文        | **平均时间复杂度** | **最坏时间复杂度** | **最好时间复杂度** | **空间复杂度** | **稳定性** |
| **希尔排序** | ShellSort | O(nlogn)    | O(ns)       | O(n)        | O(1)      | 不稳定     |

 希尔排序是插入排序改良的算法，希尔排序步长从大到小调整，第一次循环后面元素逐个和前面元素按间隔步长进行比较并交换，直至步长为1，步长选择是关键。
 
希尔排序内部调用插入排序来实现，通过对 N/2，N/4…1阶分别排序，最后得到整体的有序。

![这里写图片描述](https://i-blog.csdnimg.cn/blog_migrate/e709597933ce8cbc9110b9adff3f103a.gif)

![](https://i-blog.csdnimg.cn/blog_migrate/262a815e0e07c4eb2ecb3fb9dbb6ec06.png)

```
//下面是插入排序
void InsertSort( int array[], int n)
{
    int i,j,temp;
    for( i=0;i<n;i++ )
    {
        if(array[i]<array[i-1])
        {
            temp=array[i];
            for( j=i-1;array[j]>temp;j--)
            {
                array[j+1]=array[j];
            }
            array[j+1]=temp;
        }
    }
}

//在插入排序基础上修改得到希尔排序
void SheelSort( int array[], int n)
{
    int i,j,temp;
    int gap=n; //~~~~~~~~~~~~~~~~~~~~~
    do{
        gap=gap/3+1;  //~~~~~~~~~~~~~~~~~~
        for( i=gap;i<n;i++ )
        {
            if(array[i]<array[i-gap])
            {
                temp=array[i];
                for( j=i-gap;array[j]>temp;j-=gap)
                {
                    array[j+gap]=array[j];
                }
                array[j+gap]=temp;
            }
        }
    }while(gap>1);  //~~~~~~~~~~~~~~~~~~~~~~
 
}
```

python
```python
def shell_sort(array):
    n = len(array)
    gap = n  # Initialize gap size
    while gap > 1:
        gap = gap // 3 + 1  # Reduce the gap size
        for i in range(gap, n):  # Start sorting from the gap index
            if array[i] < array[i - gap]:
                temp = array[i]
                j = i - gap
                while j >= 0 and array[j] > temp:
                    array[j + gap] = array[j]
                    j -= gap
                array[j + gap] = temp

# Example usage:
arr = [64, 25, 12, 22, 11]
shell_sort(arr)
print("Sorted array using Shell Sort is:", arr)
```


- **Gap:** It starts with a large gap between elements and reduces it over time.
- **Sorting with Gap:** It performs a gapped insertion sort, which allows elements to be moved quickly towards their correct position.
- The gap is reduced gradually, and the array is sorted with decreasing gaps until the gap is 1 (at which point it becomes a regular insertion sort).


----


```c
/**
 * 希尔排序
 * 希尔排序内部调用插入排序来实现，通过对 N/2，N/4…1阶分别排序，最后得到整体的有序。
 */
void shellSort(int a[], int n)
{
    int gap;
    for (gap = n/2; gap > 0; gap /= 2) {
        int i;
        for (i = gap; i < n; i++) {
            int key = a[i]; 
            int j
            for (j = i; j >= gap && key < a[j-gap]; j -= gap) {
                a[j] = a[j-gap];
            }
            a[j] = key;
        }
    }
}
```

python
```python 
def shell_sort(a):
    n = len(a)
    gap = n // 2

    # Start with a big gap, then reduce the gap
    while gap > 0:
        # Perform a gapped insertion sort
        for i in range(gap, n):
            key = a[i]
            j = i

            # Shift earlier gap-sorted elements up until the correct location for `key` is found
            while j >= gap and a[j - gap] > key:
                a[j] = a[j - gap]
                j -= gap

            # Place `key` in its correct position
            a[j] = key

        # Reduce the gap for the next iteration
        gap //= 2

# Example usage:
if __name__ == "__main__":
    a = [12, 34, 54, 2, 3]
    shell_sort(a)
    print(a)  # Output should be [2, 3, 12, 34, 54]

```

- **Initial Gap Calculation**:
    - The `gap` is initialized to `n // 2`, where `n` is the length of the list `a`. The `gap` controls how far elements are spaced apart before they are compared and possibly swapped.
- **Outer Loop (Gap Reduction)**:
    - The `while gap > 0:` loop continues reducing the gap until it becomes `0`. The gap is halved (`gap //= 2`) after each pass through the list.
- **Inner Loop (Gapped Insertion Sort)**:
    - For each gap, the algorithm performs a gapped insertion sort. The `for i in range(gap, n):` loop iterates over each element in the list starting from the index `gap`.
- **Insertion Sort Mechanism**:
    - For each element `a[i]`, it is stored in the variable `key`. The loop `while j >= gap and a[j - gap] > key:` shifts elements that are greater than `key` to the right by the gap distance until the correct position for `key` is found.
- **Assigning the Key**:
    - Once the correct position is found, `key` is placed at `a[j]`.
- **Example Usage**:
    - The example usage shows how to sort a list using `shell_sort`. After sorting, the list `a` is modified in place, resulting in `[2, 3, 12, 34, 54]`.

# 8 归并排序MergeSort

|          |           |             |             |             |           |         |
| -------- | --------- | ----------- | ----------- | ----------- | --------- | ------- |
| **排序算法** | 英文        | **平均时间复杂度** | **最坏时间复杂度** | **最好时间复杂度** | **空间复杂度** | **稳定性** |
| **归并排序** | MergeSort | O(nlogn)    | O(nlogn)    | O(nlogn)    | O(n)      | 稳定      |

时间复杂度
一趟归并需要将待排序列中的所有记录 扫描一遍，因此耗费时间为O(n),而由完全二叉树的深度可知，  整个归并排序需要进行[log2n],因此，总的时间复杂度为O(nlogn),而且这是归并排序算法中平均的时间性能  

空间复杂度：由于归并过程中需要与原始记录序列同样数量级的存储空间去存放归并结果及递归深度为log2N的栈空间，因此空间复杂度为O(n+logN)  也就是说，归并排序是一种比较占内存，但却效率高且稳定的算法 

---


归并排序通过分治算法，先排序好两个子数组，然后将两个子数组归并。时间复杂度为 O(NlgN）。

 归并排序从小到大排序：首先让数组中的每一个数单独成为长度为1的区间，然后两两一组有序合并，得到长度为2的有序区间，依次进行，直到合成整个区间。

![](https://i-blog.csdnimg.cn/blog_migrate/c64f25d32e15a1cf85b94b6c292eec45.gif)


## 8.1 递归实现 

```c
/*
 * 归并排序-递归
 * */
void mergeSort(int a[], int l, int u) 
{
    if (l < u) {
        int m = l + (u-l)/2;
        mergeSort(a, l, m);
        mergeSort(a, m + 1, u);
        merge(a, l, m, u);
    }
}

/**
 * 归并排序合并函数
 */
void merge(int a[], int l, int m, int u) 
{
    int n1 = m - l + 1;
    int n2 = u - m;

    int left[n1], right[n2];
    int i, j;
    for (i = 0; i < n1; i++) /* left holds a[l..m] */
        left[i] = a[l + i];

    for (j = 0; j < n2; j++) /* right holds a[m+1..u] */
        right[j] = a[m + 1 + j];

    i = j = 0;
    int k = l;
    while (i < n1 && j < n2) {
        if (left[i] < right[j])
            a[k++] = left[i++];
        else
            a[k++] = right[j++];
    }
    while (i < n1) /* left[] is not exhausted */
        a[k++] = left[i++];
    while (j < n2) /* right[] is not exhausted */
        a[k++] = right[j++];
}
```

python
10 /5/2/1/0
```python 
def merge_sort(a, l, u):   # merge_sort(array, 0, len(a) - 1)
    if l < u:
        m = l + (u - l) // 2  # Find the middle point
        merge_sort(a, l, m)   # Sort first half
        merge_sort(a, m + 1, u)  # Sort second half
        merge(a, l, m, u)     # Merge the sorted halves

def merge(a, l, m, u):
    n1 = m - l + 1  # Length of the left subarray
    n2 = u - m      # Length of the right subarray

    left = a[l:m+1]   # Create left subarray
    right = a[m+1:u+1]  # Create right subarray

    i = j = 0  # Initial index of both subarrays
    k = l  # Initial index of the merged subarray

    # Merge the temp arrays back into a[l..u]
    while i < n1 and j < n2:
        if left[i] <= right[j]:
            a[k] = left[i]
            i += 1
        else:
            a[k] = right[j]
            j += 1
        k += 1

    # Copy the remaining elements of left[], if any
    while i < n1:
        a[k] = left[i]
        i += 1
        k += 1

    # Copy the remaining elements of right[], if any
    while j < n2:
        a[k] = right[j]
        j += 1
        k += 1

# Example usage:
if __name__ == "__main__":
    a = [12, 11, 13, 5, 6, 7]
    merge_sort(a, 0, len(a) - 1)
    print("Sorted array is:", a)  # Output should be [5, 6, 7, 11, 12, 13]


```



Explanation
1. **`merge_sort(a, l, u)` Function**:
    - **Base Case**: If the subarray has more than one element (`l < u`), the array is divided into two halves.
    - **Recursive Case**: It recursively sorts the left half (`merge_sort(a, l, m)`) and the right half (`merge_sort(a, m + 1, u)`).
    - **Merge**: After sorting the two halves, it merges them using the `merge(a, l, m, u)` function.
2. **`merge(a, l, m, u)` Function**:
    - **Create Subarrays**: The array is divided into two temporary subarrays: `left` (from `a[l]` to `a[m]`) and `right` (from `a[m+1]` to `a[u]`).
    - **Merge Process**: It compares the elements from the two subarrays and merges them back into the original array in sorted order.
    - **Remaining Elements**: Any remaining elements in either `left` or `right` subarrays are copied back to the original array.
3. **Example Usage**:
    - The example initializes an unsorted array `a = [12, 11, 13, 5, 6, 7]` and applies the `merge_sort` function to sort it. The sorted array will be `[5, 6, 7, 11, 12, 13]`.




---

下面的这个看不懂 
```c
实现归并，并把数据都放在list1里面 
void merging(int *list1, int list1_size, int *list2,  int list2_size)
{
    int i=0, j=0, k=0, m=0;
    int temp[MAXSIZE];
 
    while(i < list1_size && j < list2_size)
    {
        if(list1[i]<list2[j])
        {
            temp[k++] = list1[i++];
        }
        else
        {
            temp[k++] = list2[j++];
        }
    }
    while(i<list1_size)
    {
        temp[k++] = list1[i++];
    }
    while(j<list2_size)
    {
        temp[k++] = list2[j++];
    }
 
    for(m=0; m < (list1_size+list2_size); m++)
    {
        list1[m]=temp[m];
    }
}
//如果有剩下的，那么说明就是它是比前面的数组都大的，直接加入就可以了 
void mergeSort(int array[], int n)
{
    if(n>1)
    {
        int *list1 = array;
        int list1_size = n/2;
        int *list2 = array + n/2;
        int list2_size = n-list1_size;
 
        mergeSort(list1, list1_size);
        mergeSort(list2, list2_size);
 
        merging(list1, list1_size, list2, list2_size);
    }
}
//归并排序复杂度分析：一趟归并需要将待排序列中的所有记录  
//扫描一遍，因此耗费时间为O(n),而由完全二叉树的深度可知，  
//整个归并排序需要进行[log2n],因此，总的时间复杂度为  
//O(nlogn),而且这是归并排序算法中平均的时间性能  
//空间复杂度：由于归并过程中需要与原始记录序列同样数量级的  
//存储空间去存放归并结果及递归深度为log2N的栈空间，因此空间  
//复杂度为O(n+logN)  
//也就是说，归并排序是一种比较占内存，但却效率高且稳定的算法 
```

## 8.2 迭代实现 

归并排序的非递归实现其实是最自然的方式，先两两合并，而后再四四合并等，就是从底向上的一个过程。

Here is the non-recursive (iterative) version of the merge sort algorithm translated from C to Python:

//非递归的方法，避免了递归时深度为log2N的栈空间，空间只是用到归并临时申请的跟原来数组一样大小的空间，并且在时间性能上也有一定的提升，因此，使用归并排序是，尽量考虑用非递归的方法。


```c
/**
 * 归并排序-非递归
 */
void mergeSortIter(int a[], int n)
{
    int i, s=2;
    while (s <= n) {
        i = 0;
        while (i+s <= n){
            merge(a, i, i+s/2-1, i+s-1);
            i += s;
        }

        //处理末尾残余部分
        merge(a, i, i+s/2-1, n-1);
        s*=2;
    }
    //最后再从头到尾处理一遍
    merge(a, 0, s/2-1, n-1);
}



/**
 * 归并排序合并函数
 */
void merge(int a[], int l, int m, int u) 
{
    int n1 = m - l + 1;
    int n2 = u - m;

    int left[n1], right[n2];
    int i, j;
    for (i = 0; i < n1; i++) /* left holds a[l..m] */
        left[i] = a[l + i];

    for (j = 0; j < n2; j++) /* right holds a[m+1..u] */
        right[j] = a[m + 1 + j];

    i = j = 0;
    int k = l;
    while (i < n1 && j < n2) {
        if (left[i] < right[j])
            a[k++] = left[i++];
        else
            a[k++] = right[j++];
    }
    while (i < n1) /* left[] is not exhausted */
        a[k++] = left[i++];
    while (j < n2) /* right[] is not exhausted */
        a[k++] = right[j++];
}
```


python
```python
def merge_sort_iter(a):
    n = len(a)
    s = 2
    while s <= n:
        i = 0
        while i + s <= n:
            merge(a, i, i + s // 2 - 1, i + s - 1)
            i += s

        # Handle the remaining elements at the end of the array
        if i + s // 2 < n:
            merge(a, i, i + s // 2 - 1, n - 1)
        
        s *= 2

    # Final merge pass for any remaining elements
    merge(a, 0, s // 2 - 1, n - 1)

def merge(a, l, m, u):
    n1 = m - l + 1
    n2 = u - m

    # Create temporary arrays for left and right subarrays
    left = a[l:m+1]
    right = a[m+1:u+1]

    i = j = 0
    k = l

    # Merge the left and right subarrays back into a
    while i < n1 and j < n2:
        if left[i] <= right[j]:
            a[k] = left[i]
            i += 1
        else:
            a[k] = right[j]
            j += 1
        k += 1

    # Copy any remaining elements of left[], if any
    while i < n1:
        a[k] = left[i]
        i += 1
        k += 1

    # Copy any remaining elements of right[], if any
    while j < n2:
        a[k] = right[j]
        j += 1
        k += 1

# Example usage:
if __name__ == "__main__":
    a = [38, 27, 43, 3, 9, 82, 10]
    merge_sort_iter(a)
    print("Sorted array is:", a)  # Output should be [3, 9, 10, 27, 38, 43, 82]

```

- **`merge_sort_iter(a)` Function**:
    - **Initialization**:
        - `n = len(a)` determines the length of the array.
        - `s = 2` starts with a segment size of 2 and doubles with each iteration.
    - **Outer While Loop**:
        - The loop runs while the segment size `s` is less than or equal to `n`.
        - Inside this loop, subarrays of size `s` are merged.
    - **Inner While Loop**:
        - The array is split into segments of size `s`, and each segment is merged using the `merge()` function.
        - After processing the array in segments of size `s`, the segment size is doubled.
    - **Final Merge**:
        - After all the merges, there might be some remaining elements that have not been merged. A final merge pass is performed.
- **`merge(a, l, m, u)` Function**:
    - This function merges two subarrays of `a`:
        - The first subarray is `a[l..m]`.
        - The second subarray is `a[m+1..u]`.
    - **Temporary Arrays**:
        - Two temporary arrays, `left` and `right`, are created to hold the elements of the subarrays.
    - **Merge Process**:
        - The elements from `left` and `right` are merged back into the original array `a` in sorted order.
    - **Remaining Elements**:
        - If any elements are left in either `left` or `right`, they are copied back to the original array.
- **Example Usage**:
    - The example sorts the array `a = [38, 27, 43, 3, 9, 82, 10]` and outputs the sorted array `[3, 9, 10, 27, 38, 43, 82]`.

---


```c
void MergeSort(int k[],int n)  
{  
    int i,next,left_min,left_max,right_min,right_max;  
    //动态申请一个与原来数组一样大小的空间用来存储
    int *temp = (int *)malloc(n * sizeof(int));  
    //逐级上升，第一次比较2个，第二次比较4个，第三次比较8个。。。  
    for(i=1; i<n; i*=2)  
    {  
        //每次都从0开始，数组的头元素开始  
        for(left_min=0; left_min<n-i; left_min = right_max)  
        {  
            right_min = left_max = left_min + i;  
            right_max = left_max + i;  
            //右边的下标最大值只能为n  
            if(right_max>n)  
            {  
                right_max = n;  
            }  
            //next是用来标志temp数组下标的，由于每次数据都有返回到K，  
            //故每次开始得重新置零  
            next = 0;  
            //如果左边的数据还没达到分割线且右边的数组没到达分割线，开始循环  
            while(left_min<left_max&&right_min<right_max)  
            {  
                if(k[left_min] < k[right_min])  
                {  
                    temp[next++] = k[left_min++];  
                }  
                else  
                {  
                    temp[next++] = k[right_min++];  
                }  
            }  
            //上面循环结束的条件有两个，如果是左边的游标尚未到达，那么需要把  
            //数组接回去，可能会有疑问，那如果右边的没到达呢，其实模拟一下就可以  
            //知道，如果右边没到达，那么说明右边的数据比较大，这时也就不用移动位置了  
 
            while(left_min < left_max)  
            {  
                //如果left_min小于left_max，说明现在左边的数据比较大  
                //直接把它们接到数组的min之前就行  
                k[--right_min] = k[--left_max];   
            }  
            while(next>0)  
            {  
                //把排好序的那部分数组返回该k  
                k[--right_min] = temp[--next];        
            }  
        }  
    }  
}  
//非递归的方法，避免了递归时深度为log2N的栈空间，
//空间只是用到归并临时申请的跟原来数组一样大小的空间，并且在时间性能上也有一定的提升，
//因此，使用归并排序是，尽量考虑用非递归的方法。
```





# 9 桶排序（基数排序和基数排序的思想）


|            |                 |             |             |             |           |         |
| ---------- | --------------- | ----------- | ----------- | ----------- | --------- | ------- |
| **排序算法**   | 英文              | **平均时间复杂度** | **最坏时间复杂度** | **最好时间复杂度** | **空间复杂度** | **稳定性** |
| **冒泡排序**   | BubbleSort      | O(n²)       | O(n²)       | O(n)        | O(1)      | 稳定      |
| **直接选择排序** | SelectSort      | O(n²)       | O(n²)       | O(n)        | O(1)      | 不稳定     |
| **直接插入排序** | InsertSort      | O(n²)       | O(n²)       | O(n)        | O(1)      | 稳定      |
| **快速排序**   | QuickSort       | O(nlogn)    | O(n²)       | O(nlogn)    | O(nlogn)  | 不稳定     |
| 随机快速排序     | RandomQuickSort |             |             |             |           |         |
| **堆排序**    | HeapSort        | O(nlogn)    | O(nlogn)    | O(nlogn)    | O(1)      | 不稳定     |
| **希尔排序**   | ShellSort       | O(nlogn)    | O(ns)       | O(n)        | O(1)      | 不稳定     |
| **归并排序**   | MergeSort       | O(nlogn)    | O(nlogn)    | O(nlogn)    | O(n)      | 稳定      |
| **计数排序**   | CountSort       | O(n+k)      | O(n+k)      | O(n+k)      | O(n+k)    | 稳定      |
| **基数排序**   | Rad             | O(N*M)      | O(N*M)      | O(N*M)      | O(M)      | 稳定      |


 桶排序是计数排序的变种，把计数排序中相邻的m个”小桶”放到一个”大桶”中，在分完桶后，对每个桶进行排序（一般用快排），然后合并成最后的结果。

而桶排序则是在输入符合均匀分布时，可以以线性时间运行，桶排序的思想是把区间 `[0，1)` 划分成 N 个相同大小的子区间，将 N 个输入均匀分布到各个桶中，然后对各个桶的链表使用插入排序，最终依次列出所有桶的元素。

```c
#include <stdio.h>
int main()
{
    int a[11],i,j,t;
    for(i=0;i<=10;i++)
        a[i]=0;  //初始化为0
 
    for(i=1;i<=5;i++)  //循环读入5个数
    {
        scanf("%d",&t);  //把每一个数读到变量t中
        a[t]++;  //进行计数(核心行)
    }
 
    for(i=0;i<=10;i++)  //依次判断a[0]~a[10]
        for(j=1;j<=a[i];j++)  //出现了几次就打印几次
            printf("%d ",i);
 
    getchar();getchar(); 
    //这里的getchar();用来暂停程序，以便查看程序输出的内容
    //也可以用system("pause");等来代替
    return 0;
}
```

 
# 10 计数排序counting_sort


|          |           |             |             |             |           |         |
| -------- | --------- | ----------- | ----------- | ----------- | --------- | ------- |
| **排序算法** | 英文        | **平均时间复杂度** | **最坏时间复杂度** | **最好时间复杂度** | **空间复杂度** | **稳定性** |
| **计数排序** | CountSort | O(n+k)      | O(n+k)      | O(n+k)      | O(n+k)    | 稳定      |



假定数组为 a[0…n-1] ，数组中存在重复数字，数组中最大数字为k，建立两个辅助数组 b[] 和 c[]，b[] 用于存储排序后的结果，c[] 用于存储临时值。时间复杂度为 O(N)，适用于数字范围较小的数组。

 算法的步骤如下： 
 - 找出待排序的数组中最大和最小的元素 
 - 统计数组中每个值为i的元素出现的次数，存入数组C的第i项 
 - 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加） 
 - 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1



![这里写图片描述](https://i-blog.csdnimg.cn/blog_migrate/27592617efc4d6a2d907e86011d1ffda.jpeg)

```c
程序1：
#define NUM_RANGE (100)    //预定义数据范围上限，即K的值
 
void counting_sort(int *ini_arr, int *sorted_arr, int n)  //所需空间为 2*n+k
{  
       int *count_arr = (int *)malloc(sizeof(int) * NUM_RANGE);  
       int i, j, k;  
 
       //初始化统计数组元素为值为零 
       for(k=0; k<NUM_RANGE; k++){  
               count_arr[k] = 0;  
       }  
       //统计数组中，每个元素出现的次数    
       for(i=0; i<n; i++){  
               count_arr[ini_arr[i]]++;  
       }  
 
       //统计数组计数，每项存前N项和，这实质为排序过程
       for(k=1; k<NUM_RANGE; k++){  
               count_arr[k] += count_arr[k-1];  
       }  
 
       //将计数排序结果转化为数组元素的真实排序结果
       for(j=n-1 ; j>=0; j--){  
           int elem = ini_arr[j];          //取待排序元素
           int index = count_arr[elem]-1;  //待排序元素在有序数组中的序号
           sorted_arr[index] = elem;       //将待排序元素存入结果数组中
           count_arr[elem]--;              //修正排序结果，其实是针对算得元素的修正
       }  
       free(count_arr);  
}  
 
程序2：C++(最大最小压缩桶数)
public static void countSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        int min = arr[0];
        int max = arr[0];
        for (int i = 1; i < arr.length; i++) {
            min = Math.min(arr[i], min);
            max = Math.max(arr[i], max);
        }
        int[] countArr = new int[max - min + 1];
        for (int i = 0; i < arr.length; i++) {
            countArr[arr[i] - min]++;
        }
        int index = 0;
        for (int i = 0; i < countArr.length; i++) {
            while (countArr[i]-- > 0) {
                arr[index++] = i + min;
        }
}
```


python
```python
def counting_sort(ini_arr):
    # Determine the range of input values
    max_val = max(ini_arr) if ini_arr else 0
    min_val = min(ini_arr) if ini_arr else 0
    range_of_elements = max_val - min_val + 1

    # Create count array with all zeros
    # //初始化统计数组元素为值为零
    count_arr = [0] * range_of_elements

    # Step 1: Count the occurrences of each element in the original array
    # //统计数组中，每个元素出现的次数
    for elem in ini_arr:
        count_arr[elem - min_val] += 1

    # Step 2: Modify the count array by adding the previous counts (cumulative sum)
    # //统计数组计数，每项存前N项和，这实质为排序过程
    for i in range(1, len(count_arr)):
        count_arr[i] += count_arr[i - 1]

    # Step 3: Build the sorted array
    # //将计数排序结果转化为数组元素的真实排序结果
    sorted_arr = [0] * len(ini_arr)
    for j in range(len(ini_arr) - 1, -1, -1):  # 从最后一个元素来 往第一个元素跑  
        elem = ini_arr[j]   # //取待排序元素
        index = count_arr[elem - min_val] - 1   # //待排序元素在 Count数组中记录的这个待排序元素出现的次数, 见1
        sorted_arr[index] = elem    # //将待排序元素存入结果数组中
        count_arr[elem - min_val] -= 1   # //修正排序结果，其实是针对算得元素的修正

    return sorted_arr

# Example usage:
if __name__ == "__main__":
    ini_arr = [4, 2, 2, 8, 3, 3, 1]
    sorted_arr = counting_sort(ini_arr)
    print("Original array:", ini_arr)
    print("Sorted array:", sorted_arr)
```

1. **Range Calculation**:
    - `max_val` and `min_val` are used to determine the range of elements. This helps in handling arrays with negative values as well.
    - `range_of_elements` is calculated as `max_val - min_val + 1` to get the appropriate size for the `count_arr`.
2. **Counting Occurrences**:
    - The `count_arr` is initialized with zeros. Each element's position in the array is calculated by subtracting `min_val` from the element to handle non-zero minimum values.
3. **Cumulative Sum**:
    - The count array is transformed into a cumulative sum array to determine the positions of elements in the sorted array.
4. **Building Sorted Array**:
    - Starting from the end of the `ini_arr`, each element is placed in the correct position in the `sorted_arr` by using the cumulative counts. After placing an element, the count is decremented.
5. **Example Usage**:
    - The example usage demonstrates sorting an array using the `counting_sort` function. The original and sorted arrays are printed.

This Python implementation closely follows the logic of your C code but uses Python's list and integer handling to manage the process. The result is a sorted list `sorted_arr`, derived from the input list `ini_arr`.


---
explain: for j in range(len(ini_arr) - 1, -1, -1):
- **`range(start, stop, step)`**: The `range` function in Python generates a sequence of numbers based on the parameters provided:
    
    - **`start`**: The starting value of the sequence.
    - **`stop`**: The sequence will generate numbers up to, but not including, this value.
    - **`step`**: The difference between each consecutive number in the sequence.
- **`len(ini_arr) - 1`**: This is the index of the last element in `ini_arr`. Since list indices in Python start at `0`, the last element's index is `len(ini_arr) - 1`.
    
- **`-1` (stop)**: This tells the loop to stop just before reaching `-1`. Since Python's `range` excludes the stop value, the loop will stop at `0`, the first element in the list.
    
- **`-1` (step)**: The loop decreases the index by `1` on each iteration, which effectively makes the loop iterate from the last index to the first index.

# 11 基数排序LSDSort


|            |                 |             |             |             |           |         |
| ---------- | --------------- | ----------- | ----------- | ----------- | --------- | ------- |
| **排序算法**   | 英文              | **平均时间复杂度** | **最坏时间复杂度** | **最好时间复杂度** | **空间复杂度** | **稳定性** |
| **冒泡排序**   | BubbleSort      | O(n²)       | O(n²)       | O(n)        | O(1)      | 稳定      |
| **直接选择排序** | SelectSort      | O(n²)       | O(n²)       | O(n)        | O(1)      | 不稳定     |
| **直接插入排序** | InsertSort      | O(n²)       | O(n²)       | O(n)        | O(1)      | 稳定      |
| **快速排序**   | QuickSort       | O(nlogn)    | O(n²)       | O(nlogn)    | O(nlogn)  | 不稳定     |
| 随机快速排序     | RandomQuickSort |             |             |             |           |         |
| **堆排序**    | HeapSort        | O(nlogn)    | O(nlogn)    | O(nlogn)    | O(1)      | 不稳定     |
| **希尔排序**   | ShellSort       | O(nlogn)    | O(ns)       | O(n)        | O(1)      | 不稳定     |
| **归并排序**   | MergeSort       | O(nlogn)    | O(nlogn)    | O(nlogn)    | O(n)      | 稳定      |
| **计数排序**   | CountSort       | O(n+k)      | O(n+k)      | O(n+k)      | O(n+k)    | 稳定      |
| **基数排序**   | Rad             | O(N*M)      | O(N*M)      | O(N*M)      | O(M)      | 稳定      |


基数排序的思想是对数字每一位分别排序（注意这里必须是稳定排序，比如计数排序等，否则会导致结果错误），最后得到整体排序。

假定对 N 个数字进行排序，如果数字有 d 位，每一位可能的最大值为 K，则每一位的稳定排序需要 O(N+K) 时间，总的需要 O(d(N+K)) 时间，当 d 为常数，K=O(N) 时，总的时间复杂度为O(N)。


 基数排序是基于数据位数的一种排序算法。   
 它有两种算法   
 ①LSD–Least Significant Digit first 从低位（个位）向高位排。   
 ②MSD– Most Significant Digit first 从高位向低位（个位）排。   
 时间复杂度O(N*最大位数)。   
 空间复杂度O(N)。


![这里写图片描述](https://i-blog.csdnimg.cn/blog_migrate/0a1490bcac1f93d353b26d1e5a27f8c1.jpeg)   
 
 对a[n]按照 上面数组中 每个数据的个位数0~9进行桶排序 得到b(n)
![这里写图片描述](https://i-blog.csdnimg.cn/blog_migrate/6dfdf444d65c14a22b17aac384a646c6.jpeg)   
\
对b[n]进行累加得到c[n]，用于b[n]中重复元素计数   
 ！！！b[n]中的元素为temp中的位置！！！跳跃的用++补上：   
![这里写图片描述](https://i-blog.csdnimg.cn/blog_migrate/9fae59d99bd199d02b7fb4fc6a69802d.jpeg)   

 temp数组为排序后的数组，写回a[n]。temp为按顺序倒出桶中的数据（联合b[n],c[n],a[n]得到），重复元素按顺序输出：   
![这里写图片描述](https://i-blog.csdnimg.cn/blog_migrate/5a5d7b4ddabca2a74f796c7fdb5634d1.jpeg)


```c
//基数排序  
//LSD  先以低位排，再以高位排  
//MSD  先以高位排，再以低位排  
void LSDSort(int *a, int n)  
{  
    assert(a);  //判断a是否为空，也可以a为空||n<2返回
    int digit = 0;   //最大位数初始化
    for (int i = 0; i < n; ++i)  
    {   //求最大位数
        while (a[i] > (pow(10,digit)))  //pow函数要包含头文件math.h，pow(10,digit)=10^digit
        {  
            digit++;  
        }  
    }  
    int flag = 1;   //位数
    for (int j = 1; j <= digit; ++j)  
    {  
        //建立数组统计每个位出现数据次数（Digit[n]为桶排序b[n]）  
        int Digit[10] = { 0 };  
        for (int i = 0; i < n; ++i)  
        {  
            Digit[(a[i] / flag)%10]++;  //flag=1时为按个位桶排序
        }  
         //建立数组统计起始下标（BeginIndex[n]为个数累加c[n]，用于记录重复元素位置
         //flag=1时，下标代表个位数值，数值代表位置，跳跃代表重复）
        int BeginIndex[10] = { 0 };  
        for (int i = 1; i < 10; ++i)  
        {  
            //累加个数
            BeginIndex[i] = BeginIndex[i - 1] + Digit[i - 1];  
        }  
        //建立辅助空间进行排序 
        //下面两条可以用calloc函数实现
        int *tmp = new int[n];  
        memset(tmp, 0, sizeof(int)*n);//初始化  
        //联合各数组求排序后的位置存在temp中
        for (int i = 0; i < n; ++i)  
        {  
            int index = (a[i] / flag)%10;  //桶排序和位置数组中的下标
            //计算temp相应位置对应a[i]中的元素，++为BeginIndex数组数值加1
            //跳跃间隔用++来补，先用再++
            tmp[BeginIndex[index]++] = a[i];  
        }  
        //将数据重新写回原空间  
        for (int i = 0; i < n; ++i)  
        {  
            a[i] = tmp[i];  
        }  
        flag = flag * 10;  
        delete[] tmp;  
    }  
}  
```


```

```
