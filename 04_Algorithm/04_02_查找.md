https://blog.csdn.net/Sparkle_007/article/details/54971257

|   |   |   |   |
|---|---|---|---|
|查找|平均时间复杂度|查找条件|算法描述|
|顺序查找|O(n)|无序或有序队列|按顺序比较每个元素，直到找到关键字为止|
|二分查找（折半查找）|O(logn)|有序数组|查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。　如果在某一步骤数组为空，则代表找不到。|
|二叉排序树查找|O(logn)|二叉排序树|在二叉查找树b中查找x的过程为：  <br>1. 若b是空树，则搜索失败  <br>2. 若x等于b的根节点的数据域之值，则查找成功；  <br>3. 若x小于b的根节点的数据域之值，则搜索左子树  <br>4. 查找右子树。|
|哈希表法（散列表）|O(1)|先创建哈希表（散列表）|根据键值方式(Key value)进行查找，通过散列函数，定位数据元素。|
|分块查找|O(logn)|无序或有序队列|将n个数据元素"按块有序"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……。然后使用二分查找及顺序查找。|

|   |   |
|---|---|
|**查找算法的名称**|**时间复杂度（大O表示法）**|
|顺序查找算法|O(n)|
|二分查找算法|O(log n)|
|插补查找算法|O(log log n)|
|分块查找算法|O(log以2为底m的对数+N/m)|
|斐波拉契查找算法|O(log 2n)|
|哈希查找算法|O(1)|


- 顺序查找算法：按照数据的顺序一项一项逐个查找，所以不管数据顺序如何，都要从头到尾的遍历一次。速度比较慢，它的时间复杂度是 T=O(n)。
- 二分查找算法：将数据分割成两等份，然后用键值(要查找的数据)与中间值进行比较，逐个缩小查找范围。速度比顺序查找快，它的时间复杂度是 T=O(log n)。
- 插补查找算法：按照数据的分布，利用公式预测键值所在的位置，快速缩小键值所在序列的范围，慢慢逼近，知道查找到数据为止，这中算法比二分法查找速度还快，它的时间复杂度为 T=O(log log(n))。
- 分块查找算法：要求是顺序表，它是顺序查找算法的一种改进方法，它的时间复杂度是 T=O(log以2为底m的对数+N/m)。
- 斐波拉契查找算法：斐波拉契查找算法就是在二分法的基础上根据斐波拉契数据进行分割。用键值(想要查找的数据)与黄金分割点进行比较。逐渐缩小查找范围。它的时间复杂度是 T=O(log 2n)。
- 哈希查找算法：把一些复杂的数据，通过某种函数映射关系，映射成更加易于查找的方式。这种方法速度最快，它的时间复杂度是 T=O(1)。

